WARNING
=======

This is all very experimental. You have been warned.

Generic build instructions are at:
        http://www.rabbitmq.com/plugin-development.html


Limitations
===========

Significant limitation: rabbitmq-federation is not compatible with
clustering. *Do not deploy it in a cluster*. We intend to fix this
at some point.

Other limitations: you can't federate headers exchanges, there's no
status reporting, lots of (harmless) errors get written to the logs.


Purpose
=======

The high level goal is to transmit messages between brokers without
requiring clustering. This is useful for the following reasons:

1) Federated brokers may be in different administrative
   domains. Clustered brokers form a single administrative domain.

   a) Federated brokers may have different users and virtual hosts.
      Federated brokers only need to partially trust each other.

   b) Federated brokers may run different versions of RabbitMQ and
      Erlang.

2) Federated brokers only speak AMQP to each other, and the federation
   mechanism is designed to deal with intermittent connectivity.
   Federation is therefore much more WAN-friendly.

3) Brokers can contain federated and local-only components - you don't
   need to federate everything if you don't want to.

4) Ultimately, greater scalability should be possible, since in future
   more complex routing topology will avoid the need for n^2 connections
   between n brokers.

For the time being, the plugin provides a federated exchange
type. Other features might appear in the future. In particular this
means that federation is primarily useful in pub/sub scenarios.


HOWTO
=====

A federated exchange has type 'x-federation'. However, this type does
not provide any routing logic. The routing logic is implemented by a
backing type, provided to the exchange as an argument.

Messages can be published to a federated exchange like any
other. However, a federated exchange also receives messages from
one or more "upstream" exchanges, located on remote brokers.

(Well, you don't need to have upstream exchanges, and they don't need
to be remote. But then you don't get anything very useful.)

An upstream exchange can be a regular exchange or a federation
exchange. It is expected that upstream and downstream exchanges have
the same type (or backing type). Mixing types will lead to strange
routing behaviour.

Inter-broker communication is implemented using AMQP (optionally
secured with SSL). The federation plugin will only send messages over
the wire for which the downstream exchange has a subscription.

A typical use would be to have the same "logical" exchange distributed
over many brokers. This would be achieved by having the exchange
declared as a federated exchange in each broker, with upstreams
corresponding to all the other brokers.

Other topologies are possible; however one notable current limitation
is that the federation plugin does not forward the same message more
than once. Therefore your inter-broker topology needs to be fully
connected. We intend to remove this limitation in future.

Federated exchanges can be set up statically via broker configuration,
or declared dynamically over AMQP.


Static Configuration
====================

A reasonably verbose static configuration might look like:

  {rabbit_federation,
   [ {exchanges, [[{exchange,     "my-exchange"},
                   {virtual_host, "/"},
                   {type,         "topic"},
                   {durable,      true},
                   {auto_delete,  false},
                   {internal,     false},
                   {upstreams,    [[{host,     "upstream-server"},
                                    {protocol, "amqps"}]]}]
                 ]},
     {brokers, [[{host,            "upstream-server"},
                 {protocol,        "amqps"},
                 {username,        "myusername"},
                 {password,        "secret"},
                 {prefetch_count,  1000},
                 {reconnect_delay, 5},
                 {heartbeat,       10},
                 {queue_expires,   30}]
               ]},
     {ssl_options,
      [{cacertfile,           "/path/to/cacert.pem"},
       {certfile,             "/path/to/cert.pem"},
       {keyfile,              "/path/to/key.pem"},
       {verify,               verify_peer},
       {fail_if_no_peer_cert, true}
     ]},
     {local_username, "myusername"}
   ]
  }

The list of exchanges looks like a set of exchange.declares for the
most part, but with each declaration including a list of upstream
exchanges. Note that the type parameter must match the type of the
upstream exchanges for routing to work at all sensibly.

The upstreams parameter is a list of remote exchanges whose messages
should be federated to the local exchange. You can specify host, port,
protocol, virtual_host and exchange here. Only host is mandatory; if
protocol is omitted the protocol is taken as "amqp", and if
virtual_host or exchange are omitted the default is the same as the
downstream exchange.

Note that the static configuration will declare the downstream
exchanges (on the local broker). It does not ensure the upstream
exchanges exist.

The brokers list provides information on how to connect to brokers
mentioned in the upstreams list. It can match on the following properties:

host
  - hostname to connect to

protocol
  - "amqp" or "amqps"

virtual_host
  - if present, distinguish between different sets of broker
    properties for different virtual hosts on the same broker

And can contain the following options:

username
  - user to connect as. Default is "guest". The user will need the
    ability to create and bind exchanges and queues.

password
  - password to use. Default is "guest".

mechanism
  - SASL mechanism to use. One of:
      'default'  - to use PLAIN or AMQPLAIN by negotiation
      'EXTERNAL' - to use SASL EXTERNAL authentication - e.g.
                   rabbitmq-auth-mechanism-ssl

prefetch_count
  - limit on the maximum number of unacknowledged messages in flight
    per link. Default is none.

reconnect_delay
  - time in seconds to wait to reconnect to the broker after being
    disconnected. Default is 1.

heartbeat
  - AMQP heartbeat interval (in seconds) on the connection, or none. Default
    is none.

queue_expires
  - How long to keep the upstream queue around (and collecting
    messages) when disconnected, in seconds. Default is 1800 (half an hour).

The ssl_options parameter specifies how to make client SSL
connections. See the Erlang client documentation for more details.

The local_username parameter specifies how to connect to the local
broker. The default is "guest". This user will need the ability to
publish messages to the downstream exchange.

Declaring Federation Exchanges Over AMQP
========================================

This is a less common case, but in case you want to do this:

 * Declare the downstream exchange with type "x-federation".

 * Give it arguments "type" and "upstreams". "type" should refer to
   its backing type; the type of the upstream exchanges. "upstreams"
   should be an array of tables. Each table must have a "host" fields,
   and may also have "protocol", "port", "virtual_host" and "exchange"
   fields. TODO example.

 * Connection information and SSL parameters are still taken from the
   static configuration.

Example using the Java API:

Map<String, Object> upstream = new HashMap<String, Object>();
upstream.put("host", "remote-server");
upstream.put("exchange", "upstream-exchange");

ArrayList<Map<String, Object>> upstreams = new ArrayList<Map<String, Object>>();
upstreams.add(upstream);

Map<String, Object> args = new HashMap<String, Object>();
args.put("type", "topic");
args.put("upstreams", upstreams);

Channel ch = ...;
ch.exchangeDeclare("my-federated-exchange", "x-federation", true, false, args);


Possible Future Enhancements
============================

* Compatibility with clustering

* Simple status reporting, similar to the shovel

* Add and remove upstream brokers dynamically

* Mode to federate all exchanges

* Status information and control in the management plugin

* Smarter routing logic

* Support for RPC-like patterns
